height t4
height t2
height t1
let t1 = Node 1 t2 t3
let t2 = Node 2 t4 t5
let t3 = Node 3 t6 t7
let t4 = Node 4 Empty Empty
let t5 = Node 5 Empty Empty
let t6 = Node 6 Empty Empty
let t7 = Node 7 Empty Empty
height t7
:load height.hs 
:?
:delete 
:reload
size t7
size t6
size t5
size t4
size t3
size t2
size t1
let t1 = Node 1 t2 t3
let t2 = Node 2 t4 t5
let t3 = Node 3 t6 t7
let t4 = Node 4 Empty Empty
let t5 = Node 5 Empty Empty
let t6 = Node 6 Empty Empty
let t7 = Node 7 Empty Empty
:type Empty 
:load size.hs 
take 20 hammings 
take 10 hammings 
:load hammings.hs 
take 10 primes 
:load primes.hs 
take 10 primes
:load primes.hs 
div 11 2
11 div 2
take 10 fibs
:load fibs.hs 
take 20 factorials 
take 5 factorials 
:load factorials.hs 
take 10 $ iterate (+1) 1
take 10 triangulars 
take 6 triangulars 
:load triangulars.hs 
iterate (+1) 1
scanl (/) 64 [4,2,4]
foldl (/) 64 [4,2,4]
take 10 $ iterate (+2) 3
take 10 $ iterate (+2) 0
iterate (+2) 0
print 0
iterate print 0
iterate 1
(+1) 1
take 20 ints
take 10 ints
take 8 ints
:load ints.hs 
take 10 nats
:load nats.hs 
:type iterate 
take 20 $ concat $ repeat "hi"
take 5 $ concat $ repeat "hi"
take 5 $ concat . repeat "hi"
take 5 $ repeat "hi"
take 5 $ repeat 'hi'
take 5 $ repeat 'x'
take 8 ones
take 5 ones
:load ones.hs 
ord 'b'
ord 'a'
:type ord
import Data.Char (ord)
filterFoldl even (*) 1 [1,3,4,2,10]
filterFoldl even (*1) [1,3,4,2,10]
filterFoldl even * 1 [1,3,4,2,10]
:load problems/filterFoldl.hs 
consecutive [1,2,3] [(*2),(+3),(^2)]
consecutive [1,2,3] [(*2),(+3)]
:load problems/consecutive.hs 
combined [1,2,3] [(*2),(+3),((-)3)]
combined [1,2,3] [(*2),(+3),(*3)]
combined [1,2,3] [(*2),(+3),(-3)]
:load problems/combined.hs 
[x*2 | x <- [1..5]]
:}
}:
:{
:}
print x*2 | x <- [1,2,3,4,5]
x*2 | x <- [1,2,3,4,5]
:{
{x*2 | x <- [1,2,3,4,5]}
{x*2 | x <- [1,2,3,4,5]
